    public int reverse(int x) {
        // int rev = 0;
        // while (x != 0){
        //     int pop = x % 10;
        //     x /= 10;
        //     //consideration: rev * 10 + pop >(?)(if positive) MAX_VALUE
        //     //The first case is that rev * 10 > MAX_VALUE
        //     //The second case is that rev * 10 == MAX_VALUE, but would bigger than MAX_VALUE if plus pop, which is regarded as the unit digit
        //     if(rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;//7 is the unit digit of 2^31-1
        //     if(rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;//-8 is the unit digit of -2^31-1
        //     rev = rev * 10 +pop;
        // }
        // return rev;

        int rev = 0;
        while (x != 0){
            int pop = x % 10;
            x /= 10;
            //I like this solution more. Who care the other complex cases?
            try{
                rev = rev * 10 + pop;               
            }
            catch(Exception e){
                System.out.println("The result beyonds the range!");
                return 0;
            }
        }
        return rev;
    }
    //link: https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/
